This is a simple interpreter of a basic programming language.

It consists of a lexer, parser and back-end evaluator.
The interpreter.py file reads a source file and feeds it to the lexer.
The lexer takes this string as input and produces a list of tokens.
The parser is then fed this list, which it converts to a tree of classes.
This tree is then evaluated via small-step semantics with the evaluator.

To run the program, type:

python interpreter.py <file_name>

If no file name is given, it will attempt to run a file called 'test' in the same directory.

It can comprehend:
  -integers, booleans and strings
  -expressions
  -variables
  -assignments
  -sequences of statements
  -if statements
  -while loops
  -function definitions and calls
    -closure supported and functions can be passed as variables
    -currying
    -function scope
  -special print(val) and input(val) functions
  -pairs, with car(p), cdr(p), p=setcar(p,newcar) and p=setcdr(p,newcdr) functions for pair 'p'
  -comments (//comment\n)

The EBNF semantics can be seen in the parser.py file.

Planned features:
  -Lambda expressions
  -Scope for if and while statements (?)
  -Multi-file programs (import <filename>) and libraries
  -Lists and map(), reduce() and filter() ops
  -Greater type functionality
    -Strong typing
    -Type declarations for functions (?)
    -Structures, unions, enumerations
    -Classes and objects
  -Lazy evaluation


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


The language is weakly typed, so variables can have any value at any time.


x = 5;            // Integer
x = "Hello";      // String
x = false;        // Boolean
x = [1, "hey!"];  // Pair (can take any data types as vals)


Several operations and comparisons are supported: +, -, *, /, %, >, <, and ==.
Functions are also considered a data type, so are assigend to variables.


f = function(x,y){  // Function (indentation not necessary, can be on one line)
  return x+y;
};
y = f(5,6);  // y = 11
g = f;       // g can now be called as a function
t = g(1,2);  // t = 3


Closure is also supported.


f = function(x){
  return function(a){ return x+a; };
};
g = f(2);  // g = function(a){return 2+a;};
x = g(4);  // x = 6


Currying is another supported feature.


add = function(x,y){    // Example multi argument function
  return x+y;
};
curried = curry(add);   // Curried version of 'add' function
addfive = curried(5);
print(addfive(6));      // Prints '11'


Note how print(curry(add)(5)(6)); is not used, as the semantics of the language don't accept it for now.
Pairs have several special functions.


p = [1, 2];             // Create pair
x = car(p);             // x = 1
y = cdr(p);             // y = 2
a = setcar(p, false);   // a = [false, 2]  (does NOT alter p)
b = setcdr(p, [2,3]);   // b = [1, [2, 3]] (does NOT alter p)


For input and output, print() and input() can be used.


print(5);                       // Print out value 5
x = function(x){return x+1};
print(x);                       // Print out function
y = input("Type something: ")   // print out "Type something: ", y = whatever is typed


For control flow, if statements and while loops are available.


x = 5;

if(x>0) then {
  print("x is big");
} else {
  print("x is nothing");
}

while(x > 0) {
  x = x-1;
  print("x is " + x);  // NB: strings and other data types can be concatenated.
}


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
