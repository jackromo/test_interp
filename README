This is a simple interpreter of a basic programming language.

It consists of a lexer, parser and back-end evaluator.
The interpreter.py file reads a source file and feeds it to the lexer.
The lexer takes this string as input and produces a list of tokens.
The parser is then fed this list, which it converts to a tree of classes.
This tree is then evaluated via small-step semantics with the evaluator.

To run the program, type:

python interpreter.py <file_name>

If no file name is given, it will attempt to run a file called 'test' in the same directory.

It can comprehend:
  -expressions
  -variables
  -assignments
  -sequences of statements
  -if statements
  -while loops
  -function definitions and calls
  -pairs, with car(p), cdr(p), p=setcar(p,newcar) and p=setcdr(p,newcdr) functions for pair 'p'.

Here is the EBNF semantics:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

program = statement EOF
;

statement = sequence
    | assign
    | donothing
    | ifstmt
    | whilestmt
    | define
;

sequence = [assign|donothing|ifstmt|whilestmt|define] statement
;

ifstmt = IF expression THEN CLPAREN statement CRPAREN ELSE CLPAREN statement CRPAREN
;

whilestmt = WHILE expression CLPAREN statement CRPAREN
;

assign = variable ASGN expression EOL
;

donothing = NULL EOL
;

variable = VAR
;

//Define a function
define = VAR LPAREN {VAR {COMMA VAR}*}? RPAREN ASGN CLPAREN statement CRPAREN
;

expression = atom OP expression
    | conditional
    | LPAREN expression RPAREN
    | atom
    | execute
;

//Execute a function
execute = VAR LPAREN {expression {COMMA expression}*}? RPAREN
;

conditional = expression COMP expression
;

atom = variable
    | NUM
    | BOOL
    | pair
;

//pair definition
pair = SLPAREN expression COMMA expression SRPAREN
;

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Planned features:
  -Comments (// and /* */)
  -Print() and input() functions
  -Multi-file programs (import <filename>) and libraries
